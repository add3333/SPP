'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = watch;

function path() {
  const data = _interopRequireWildcard(require('path'));

  path = function () {
    return data;
  };

  return data;
}

function _ansiEscapes() {
  const data = _interopRequireDefault(require('ansi-escapes'));

  _ansiEscapes = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require('chalk'));

  _chalk = function () {
    return data;
  };

  return data;
}

function _exit() {
  const data = _interopRequireDefault(require('exit'));

  _exit = function () {
    return data;
  };

  return data;
}

function _slash() {
  const data = _interopRequireDefault(require('slash'));

  _slash = function () {
    return data;
  };

  return data;
}

function _jestMessageUtil() {
  const data = require('jest-message-util');

  _jestMessageUtil = function () {
    return data;
  };

  return data;
}

function _jestUtil() {
  const data = require('jest-util');

  _jestUtil = function () {
    return data;
  };

  return data;
}

function _jestValidate() {
  const data = require('jest-validate');

  _jestValidate = function () {
    return data;
  };

  return data;
}

function _jestWatcher() {
  const data = require('jest-watcher');

  _jestWatcher = function () {
    return data;
  };

  return data;
}

var _FailedTestsCache = _interopRequireDefault(require('./FailedTestsCache'));

var _SearchSource = _interopRequireDefault(require('./SearchSource'));

var _TestWatcher = _interopRequireDefault(require('./TestWatcher'));

var _getChangedFilesPromise = _interopRequireDefault(
  require('./getChangedFilesPromise')
);

var _activeFiltersMessage = _interopRequireDefault(
  require('./lib/activeFiltersMessage')
);

var _createContext = _interopRequireDefault(require('./lib/createContext'));

var _isValidPath = _interopRequireDefault(require('./lib/isValidPath'));

var _updateGlobalConfig = _interopRequireDefault(
  require('./lib/updateGlobalConfig')
);

var _watchPluginsHelpers = require('./lib/watchPluginsHelpers');

var _FailedTestsInteractive = _interopRequireDefault(
  require('./plugins/FailedTestsInteractive')
);

var _Quit = _interopRequireDefault(require('./plugins/Quit'));

var _TestNamePattern = _interopRequireDefault(
  require('./plugins/TestNamePattern')
);

var _TestPathPattern = _interopRequireDefault(
  require('./plugins/TestPathPattern')
);

var _UpdateSnapshots = _interopRequireDefault(
  require('./plugins/UpdateSnapshots')
);

var _UpdateSnapshotsInteractive = _interopRequireDefault(
  require('./plugins/UpdateSnapshotsInteractive')
);

var _runJest = _interopRequireDefault(require('./runJest'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== 'function') return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
    return {default: obj};
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor =
    Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor
        ? Object.getOwnPropertyDescriptor(obj, key)
        : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const {print: preRunMessagePrint} = _jestUtil().preRunMessage;

let hasExitListener = false;
const INTERNAL_PLUGINS = [
  _FailedTestsInteractive.default,
  _TestPathPattern.default,
  _TestNamePattern.default,
  _UpdateSnapshots.default,
  _UpdateSnapshotsInteractive.default,
  _Quit.default
];
const RESERVED_KEY_PLUGINS = new Map([
  [
    _UpdateSnapshots.default,
    {
      forbiddenOverwriteMessage: 'updating snapshots',
      key: 'u'
    }
  ],
  [
    _UpdateSnapshotsInteractive.default,
    {
      forbiddenOverwriteMessage: 'updating snapshots interactively',
      key: 'i'
    }
  ],
  [
    _Quit.default,
    {
      forbiddenOverwriteMessage: 'quitting watch mode'
    }
  ]
]);

async function watch(
  initialGlobalConfig,
  contexts,
  outputStream,
  hasteMapInstances,
  stdin = process.stdin,
  hooks = new (_jestWatcher().JestHook)(),
  filter
) {
  // `globalConfig` will be constantly updated and reassigned as a result of
  // watch mode interactions.
  let globalConfig = initialGlobalConfig;
  let activePlugin;
  globalConfig = (0, _updateGlobalConfig.default)(globalConfig, {
    mode: globalConfig.watch ? 'watch' : 'watchAll',
    passWithNoTests: true
  });

  const updateConfigAndRun = ({
    bail,
    changedSince,
    collectCoverage,
    collectCoverageFrom,
    collectCoverageOnlyFrom,
    coverageDirectory,
    coverageReporters,
    findRelatedTests,
    mode,
    nonFlagArgs,
    notify,
    notifyMode,
    onlyFailures,
    reporters,
    testNamePattern,
    testPathPattern,
    updateSnapshot,
    verbose
  } = {}) => {
    const previousUpdateSnapshot = globalConfig.updateSnapshot;
    globalConfig = (0, _updateGlobalConfig.default)(globalConfig, {
      bail,
      changedSince,
      collectCoverage,
      collectCoverageFrom,
      collectCoverageOnlyFrom,
      coverageDirectory,
      coverageReporters,
      findRelatedTests,
      mode,
      nonFlagArgs,
      notify,
      notifyMode,
      onlyFailures,
      reporters,
      testNamePattern,
      testPathPattern,
      updateSnapshot,
      verbose
    });
    startRun(globalConfig);
    globalConfig = (0, _updateGlobalConfig.default)(globalConfig, {
      // updateSnapshot is not sticky after a run.
      updateSnapshot:
        previousUpdateSnapshot === 'all' ? 'none' : previousUpdateSnapshot
    });
  };

  const watchPlugins = INTERNAL_PLUGINS.map(
    InternalPlugin =>
      new InternalPlugin({
        stdin,
        stdout: outputStream
      })
  );
  watchPlugins.forEach(plugin => {
    const hookSubscriber = hooks.getSubscriber();

    if (plugin.apply) {
      plugin.apply(hookSubscriber);
    }
  });

  if (globalConfig.watchPlugins != null) {
    const watchPluginKeys = new Map();

    for (const plugin of watchPlugins) {
      const reservedInfo = RESERVED_KEY_PLUGINS.get(plugin.constructor) || {};
      const key = reservedInfo.key || getPluginKey(plugin, globalConfig);

      if (!key) {
        continue;
      }

      const {forbiddenOverwriteMessage} = reservedInfo;
      watchPluginKeys.set(key, {
        forbiddenOverwriteMessage,
        overwritable: forbiddenOverwriteMessage == null,
        plugin
      });
    }

    for (const pluginWithConfig of globalConfig.watchPlugins) {
      let plugin;

      try {
        const ThirdPartyPlugin = await (0, _jestUtil().requireOrImportModule)(
          pluginWithConfig.path
        );
        plugin = new ThirdPartyPlugin({
          config: pluginWithConfig.config,
          stdin,
          stdout: outputStream
        });
      } catch (error) {
        const errorWithContext = new Error(
          `Failed to initialize watch plugin "${_chalk().default.bold(
            (0, _slash().default)(
              path().relative(process.cwd(), pluginWithConfig.path)
            )
          )}":\n\n${(0, _jestMessageUtil().formatExecError)(
            error,
            contexts[0].config,
            {
              noStackTrace: false
            }
          )}`
        );
        delete errorWithContext.stack;
       